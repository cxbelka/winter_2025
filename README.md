# winter_2025

## Требования

- golang 1.23 (для запуска тестов)
- docker 24.0.2
- docker-compose 2.32.4
- make 

## Запуск приложения и тестов

- Приложение запускается через docker-compose.yaml или через Makefile в корне проекта (`make run`)

- Unit и E2E тесты запускаются командой `make test`

- Нагрузочное тестирование запускается командой `make load`

## Проблемы и их решения

### Разбиение слоёв на модули

__Репозиторий__

Для данной задачи оказалось избыточно сложно спроектировать репозитории в чётком соответствии с таблицами.
Из заданного списка запросов чёткие границы ответственности имеет только эндпоинт авторизации.
С другой стороны, получение информации и операции с монетками требуют проверки баланса, а информация о балансе фактически принадлежит пользователю, а значит репозиторию авторизации/таблице с пользователями.
Какой оптимальный маппинг запросов на модули репозитория?

__Решение__

На слое репозиториев появляются две сущности связанные с таблицей пользователей:
- `auth`, ответственный за работу с пользователями
- `balance`, отвечающий за баланс конкретного пользователя

Остальные две сущности (переводы и покупки) при этом хорошо изолируются.

Структуры таблиц данных можно увидеть [тут](/migrations/init.sql).

__Слой бизнес-логики__

С точки зрения SOLID логичным выглядит разделение слоя бизнес-логики на 4 сущности, соответствующих входящим запросам.
А с другой стороны, учитывая минимальное количество логики на этом уровне, каждая сущность получается слишком мелкой и прямолинейной.
Как оптимально сопоставить и сгруппироавть запросы со слоем бизнес-логики?

__Решение__

Флоу авторизации имеет чёткие границы и обладает заметным объёмом бизнес-логики (проверка пользователя/генерация токена), то его логично выделить отдельно. При этом проверка токена будет встроена в миддлварь, поэтому операции с токеном логично вынести в отдельный модуль для удобства импортирования.

Остальные модули с минимальной логикой собрать в один (`accountant`)

### Транзакции

Финансовые операции должны быть атомарны. Особенно если дело касается нескольких одновременных манипуляций с изменениями нескольких балансов в рамках одной финансовой операции. Что приводит к мысли о необходимости внедрения транзакций. 

Операция проверки наличия достаточной суммы на счету баланса с блокировкой так же обязательна для включения в транзакцию, как и запись операции в одну из "исторических" таблиц. 

Особенно при переводе монеток между пользователями происходит одновременное изменение балансов источника и приёмника "денежной" суммы. 
При этом логика вызова функций изменения балансов находится на бизнес-слое, что в свою очередь требует вынесения обёртки транзакций за пределы отдельно взятого модуля репозитория. Данное решение является достаточно громоздким и усложняет внутреннюю архитектуру приложения.
Какие ещё могут быть варианты?

__Решение__

Проверка может быть произведена до проведения транзакции и быть отдельна от неё если гарантировано, что баланс не может уйти в отрицательные значения за счёт ограничения уровня БД. Для этого можно использовать в полях таблиц механизм `CONSTRAINT`.

Учитывая, что единичный запрос сам по себе является атомарным, можно сгруппировать запросы на изменение пользовательского баланса и вставку информации в "историческую" таблицу в один запрос, используя оператор `WITH`. И тоже самое при переводе сумм между пользователями.

### Обработка и проброс ошибок, маппинг ошибок на транспорт

Ещё одна проблема заключается в том, с минимальным нарушением принципа Single Responsibility перевести ошибки от слоя БД на слой транспорта. 

Какие ошибки возникают от БД и как они должны отображаться на клиенте? Согласно ТЗ, ошибок всего 3 типа: 400 (Bad Request), 401 (Unauthorized) и 500 (Internal Server Error).
Ошибка от базы данных при нарушении констрейнта поля таблицы должны отдаваться как 400, а не 500.
Классическое решение в том, что объекты ошибок создаются на каждом слое и на вышележащем мапятся в необходимые внутренние ошибки. Для данного ТЗ это избыточно.

__Решение__

Создать общие для всех слоёв (кроме транспорта) модели ошибок.
Слой траспорта использует модели для генерации ошибок своего уровня.

### Логирование

Стандартный приём логирования состоит в том, что ошибки логируются там, где они возникают. Недостаток этого метода в том, что это не удобно с точки зрения разработки, поскольку нарушается связанность записей.

__Решение__

Поля для логирования откладывать в контекст, а запись в журнал логирования происходит в миддлвари. Минусом решения является необходимость создавать отдельный пакет с обвязкой для работы с логами и контекстом.

### Тестирование 

Учитывая, что я в принципе, раньше не писала что-либо подобное, то само задание является проблемой.

__Решение__

Идти к своему ментору по рабработке и садиться ему на шею со словами "Объясняй что это такое и как оно делается?! Начиная от самых основ".
Скрипт вышел немного некрасивый, но поскольку я только начинаю это осваивать, то приношу свои извинения и принимаю конструктивную критику.

Результаты:
```
sleep...
start
time=2025-02-15T21:41:49.082+03:00 level=ERROR msg=failed err="p2p: 38842 failed: code 400"
time=2025-02-15T21:42:02.292+03:00 level=ERROR msg=failed err="p2p: 61364 failed: code 400"
time=2025-02-15T21:42:08.531+03:00 level=ERROR msg=failed err="p2p: 72003 failed: code 400"


auth:
rqs: 100000, time: 58.3s
avg: 1714.4rps, 3.10 ms/rq | Q[99: 13.23, 95: 4.95, 50: 2.46]ms
errors: 0, SLI: 100.00%

re-auth:
rqs: 100000, time: 62.1s
avg: 1610.4rps, 1.18 ms/rq | Q[99: 2.16, 95: 1.46, 50: 1.12]ms
errors: 0, SLI: 100.00%

p2p:
rqs: 100000, time: 58.8s
avg: 1700.5rps, 1.80 ms/rq | Q[99: 3.42, 95: 2.30, 50: 1.66]ms
errors: 3, SLI: 100.00%

info:
rqs: 100000, time: 62.1s
avg: 1610.2rps, 2.18 ms/rq | Q[99: 5.60, 95: 3.05, 50: 1.98]ms
errors: 0, SLI: 100.00%
```

В данном случае ошибки '400' означают, что при рандомной генерации перевода монет источник и приёмник перевода совпали. 

В процессе нагрузочного тестирования был получен ожидаемый результат по эндпоинту `info`. Это связано с тем, что PostgreSQL не очень хорошо справляется с аналитическими запросами,
и время выполнения данного энтпоинта может превышать заданный SLI.

Первым решение проблемы является предгруппированные таблицы переводов и покупок.

Вторым и более логичным решением является переносом отчётности на clickhouse.