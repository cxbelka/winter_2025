# winter_2025

## Требования

- golang 1.23 (для запуска тестов)
- docker 24.0.2
- docker-compose 2.32.4
- make 

## Запуск приложения и тестов

- Приложение запускается через docker-compose.yaml или через Makefile в корне проекта (`make run`)

- Unit и E2E тесты запускаются командой `make test`

- Нагрузочное тестирование запускается командой `make load`

## Проблемы и их решения

### Разбиение слоёв на модули

__Репозиторий__

Для данной задачи оказалось избыточно сложно спроектировать репозитории в чётком соответствии с таблицами.
Из заданного списка запростов чёткие границы ответственности имеет только эндпоинт авторизации.
С другой стороны, получение информации и операции с монетками требуют проверки баланса, а информация о балансе фактически принадлежит пользователю, а значит репозиторию авторизации/таблице с пользователями.
Какой оптимальный маппинг запросов на модули репозитория?

__Решение__

На слое репозиториев появляются две сущности связанные с таблицей пользователей:
- `auth` - ответственный за работу с пользователями
- `balance` - отвечающий за баланс конкретного пользователя

Остальные две сущности (переводы и покупки) при этом хорошо изолируются.

Структуры таблиц данных можно увидеть [тут](/migrations/init.sql).

__Слой бизнес-логики__

С точки зрения SOLID логичным выглядит разделение слоя бизнес-логики на 4 сущности, соответствующих входящим запросам.
А с другой стороны, учитывая минимальное количество логики на этом уровне, каждая сущность получается слишком мелкой и прямолинейной.
Как оптимально сопоставить и сгруппироавть запросы со слоем бизнес-логики?

__Решение__

Учитывая, что флоу авторизации имеет чёткие границы и обладает заметным объёмом бизнес-логики (проверка пользователя/генерация токена), то его логично выделить отдельно. При этом проверка токена будет встроена в миддлварь, поэтому операции с токеном вынести в отдельный модуль для удобства импортирования.

Остальные модули с минимальной логикой собрать в один (`accountant`)

### Транзакции

Финансовые операции должны быть атомарны. Особенно если дело касается нескольких одновременных манипуляций с изменениями нескольких балансов в рамках одной финансовой операции. Что приводит к мысли о необходимости внедрения транзакций. 

Операции проверки наличия достаточной суммы на счету баланса с блокировкой так же обязательна для включения в транзакцию, как и запись информации об операции в одну из "исторических" таблиц. 

Особенно при переводе монеток между пользователями происходит одновременное изменение балансов источника и приёмника "денежной" суммы. 
При этом логика вызова функций изменения балансов находится на бизнес-слое, что в свою очередь требует вынесения обёртки транзакций за пределы отдельно взятого модуля репозитория. Данное решение является достаточно громоздким и усложняет внутреннюю архитектуру приложения.
Какие ещё могут быть варианты?

__Решение__

Проверка может быть произведена до проведения транзакции и быть отдельна от неё если гарантировано, что баланс не может уйти в отрицательные значения за счёт ограничения уровня БД. Для этого можно использовать в полях таблиц механизм `CONSTRAINT`.

Учитывая, что единичный запрос сам по себе является атомарным, можно сгруппировать запросы на изменение пользовательского баланса и вставку информации в "историческую" таблицу в один запрос, используя оператор `WITH`. И тоже самое при переводе сумм между пользователями.

### Обработка и проброс ошибок, маппинг ошибок на транспорт

### Логирование

### Скрипт нагрузочного тестирования

### U-tests & E2E-tests