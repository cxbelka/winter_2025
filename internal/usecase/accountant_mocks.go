// Code generated by MockGen. DO NOT EDIT.
// Source: accountant.go
//
// Generated by this command:
//
//	mockgen -package usecase -source=accountant.go -destination=accountant_mocks.go *
//

// Package usecase is a generated GoMock package.
package usecase

import (
	context "context"
	reflect "reflect"

	models "github.com/cxbelka/winter_2025/internal/models"
	gomock "go.uber.org/mock/gomock"
)

// Mockbalance is a mock of balance interface.
type Mockbalance struct {
	ctrl     *gomock.Controller
	recorder *MockbalanceMockRecorder
	isgomock struct{}
}

// MockbalanceMockRecorder is the mock recorder for Mockbalance.
type MockbalanceMockRecorder struct {
	mock *Mockbalance
}

// NewMockbalance creates a new mock instance.
func NewMockbalance(ctrl *gomock.Controller) *Mockbalance {
	mock := &Mockbalance{ctrl: ctrl}
	mock.recorder = &MockbalanceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockbalance) EXPECT() *MockbalanceMockRecorder {
	return m.recorder
}

// GetBalance mocks base method.
func (m *Mockbalance) GetBalance(ctx context.Context, name string) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalance", ctx, name)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockbalanceMockRecorder) GetBalance(ctx, name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*Mockbalance)(nil).GetBalance), ctx, name)
}

// Mockp2p is a mock of p2p interface.
type Mockp2p struct {
	ctrl     *gomock.Controller
	recorder *Mockp2pMockRecorder
	isgomock struct{}
}

// Mockp2pMockRecorder is the mock recorder for Mockp2p.
type Mockp2pMockRecorder struct {
	mock *Mockp2p
}

// NewMockp2p creates a new mock instance.
func NewMockp2p(ctrl *gomock.Controller) *Mockp2p {
	mock := &Mockp2p{ctrl: ctrl}
	mock.recorder = &Mockp2pMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockp2p) EXPECT() *Mockp2pMockRecorder {
	return m.recorder
}

// ListReceived mocks base method.
func (m *Mockp2p) ListReceived(ctx context.Context, user string) ([]models.ReceivedTransfer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListReceived", ctx, user)
	ret0, _ := ret[0].([]models.ReceivedTransfer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListReceived indicates an expected call of ListReceived.
func (mr *Mockp2pMockRecorder) ListReceived(ctx, user any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListReceived", reflect.TypeOf((*Mockp2p)(nil).ListReceived), ctx, user)
}

// ListSent mocks base method.
func (m *Mockp2p) ListSent(ctx context.Context, user string) ([]models.SentTransfer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListSent", ctx, user)
	ret0, _ := ret[0].([]models.SentTransfer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSent indicates an expected call of ListSent.
func (mr *Mockp2pMockRecorder) ListSent(ctx, user any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSent", reflect.TypeOf((*Mockp2p)(nil).ListSent), ctx, user)
}

// Transfer mocks base method.
func (m *Mockp2p) Transfer(ctx context.Context, from, to string, amount int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Transfer", ctx, from, to, amount)
	ret0, _ := ret[0].(error)
	return ret0
}

// Transfer indicates an expected call of Transfer.
func (mr *Mockp2pMockRecorder) Transfer(ctx, from, to, amount any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Transfer", reflect.TypeOf((*Mockp2p)(nil).Transfer), ctx, from, to, amount)
}

// Mockshop is a mock of shop interface.
type Mockshop struct {
	ctrl     *gomock.Controller
	recorder *MockshopMockRecorder
	isgomock struct{}
}

// MockshopMockRecorder is the mock recorder for Mockshop.
type MockshopMockRecorder struct {
	mock *Mockshop
}

// NewMockshop creates a new mock instance.
func NewMockshop(ctrl *gomock.Controller) *Mockshop {
	mock := &Mockshop{ctrl: ctrl}
	mock.recorder = &MockshopMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockshop) EXPECT() *MockshopMockRecorder {
	return m.recorder
}

// BuyItem mocks base method.
func (m *Mockshop) BuyItem(ctx context.Context, buyer, item string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BuyItem", ctx, buyer, item)
	ret0, _ := ret[0].(error)
	return ret0
}

// BuyItem indicates an expected call of BuyItem.
func (mr *MockshopMockRecorder) BuyItem(ctx, buyer, item any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuyItem", reflect.TypeOf((*Mockshop)(nil).BuyItem), ctx, buyer, item)
}

// ListPurchases mocks base method.
func (m *Mockshop) ListPurchases(ctx context.Context, user string) ([]models.InventoryItem, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListPurchases", ctx, user)
	ret0, _ := ret[0].([]models.InventoryItem)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListPurchases indicates an expected call of ListPurchases.
func (mr *MockshopMockRecorder) ListPurchases(ctx, user any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPurchases", reflect.TypeOf((*Mockshop)(nil).ListPurchases), ctx, user)
}
